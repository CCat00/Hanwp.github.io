<!DOCTYPE html><html lang="zh_CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS10新特性-UserNotifications · 灭神的技术博客</title><meta name="description" content="iOS10新特性-UserNotifications - 灭神"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://hanwp.github.io/atom.xml" title="灭神的技术博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Hanwp" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS10新特性-UserNotifications</h1><div class="post-info">2016年10月8日</div><div class="post-content"><blockquote>
<p>iOS10增加了新的通知框架<code>UserNotifications</code>，整合了本地通知和APNS，新的API使用起来特别舒服。这篇文章就大概介绍一下新的框架。</p>
</blockquote>
<p>###新的特性：</p>
<ul>
<li>通知可以附加图片、音频、视频</li>
<li>可以对通知更新、删除</li>
<li>统一本地通知和APNS</li>
</ul>
<p>#权限申请<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@import UserNotifications;</span><br><span class="line">// 请求使用通知</span><br><span class="line">[[UNUserNotificationCenter currentNotificationCenter] requestAuthorizationWithOptions:UNAuthorizationOptionBadge | UNAuthorizationOptionSound | UNAuthorizationOptionAlert completionHandler:^(BOOL granted, NSError * _Nullable error) &#123;</span><br><span class="line">       if (granted) &#123;</span><br><span class="line">           //用户同意使用通知</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure></p>
<p>第一次调用这个方法时，会弹出一个系统弹窗。<br><img src="http://upload-images.jianshu.io/upload_images/852660-bf32a6da0243c4c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UNNotification_author.png"><br>要注意的是，一旦用户拒绝了这个请求，再次调用该方法也不会再进行弹窗，想要应用有机会接收到通知的话，用户必须自行前往系统的设置中为你的应用打开通知。</p>
<p><em>远程推送</em></p>
<p>用户同意了通知申请之后，就可以进行本地通知了。如果要进行远程推送，还需要获取token。然后服务器根据这个token，向<code>Apple Push Notification Service</code>服务器提交请求，然后<code>APNS</code>通过token识别用户，推送给用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//向APNS请求token</span><br><span class="line">    [[UIApplication sharedApplication] registerForRemoteNotifications];</span><br><span class="line">//请求token成功</span><br><span class="line">- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通知权限</strong><br>可以通知下面的这个方法，检查当前APP的通知权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[UNUserNotificationCenter currentNotificationCenter] getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) &#123;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p>
<p>#发送通知<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 创建通知</span><br><span class="line">    UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init];</span><br><span class="line">    content.title = @&quot;这是一条通知的标题&quot;;</span><br><span class="line">    content.body = @&quot;这是一条通知的内容&quot;;</span><br><span class="line">    content.categoryIdentifier = @&quot;ceshi&quot;;</span><br><span class="line">    </span><br><span class="line">    // 创建发送触发</span><br><span class="line">    UNTimeIntervalNotificationTrigger *trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:5 repeats:NO];</span><br><span class="line">    </span><br><span class="line">    // 发送请求标识符</span><br><span class="line">    NSString *identifier = @&quot;com.hanwei.firstNotificationIndentifier&quot;;</span><br><span class="line">    </span><br><span class="line">    // 创建一个通知请求</span><br><span class="line">    UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:identifier content:content trigger:trigger];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 将请求添加到通知中心</span><br><span class="line">    [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123;</span><br><span class="line">        if (!error) &#123;</span><br><span class="line">            NSLog(@&quot;通知添加成功&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p>
<p>发送通知成功之后，就可以回到首页，或者锁屏查看了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/852660-7380841edf400908.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UNNotification_home.png"></p>
<p>#取消和更新通知<br>远程推送只能更新，不能取消已经展示过的通知。<br><em>取消</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 移除展示过的通知</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(6 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [[UNUserNotificationCenter currentNotificationCenter] removeDeliveredNotificationsWithIdentifiers:@[identifier]];</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"> //移除还未展示的通知</span><br><span class="line">[[UNUserNotificationCenter currentNotificationCenter] removePendingNotificationRequestsWithIdentifiers:@[identifier]];</span><br></pre></td></tr></table></figure></p>
<p><strong>更新</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    // 不管通知是否已经展示过，都可以根据标示进行通知的更新</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(8 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">//        NSLog(@&quot;两秒钟后更新通知内容&quot;);</span><br><span class="line">        </span><br><span class="line">        // 创建发送触发</span><br><span class="line">        UNTimeIntervalNotificationTrigger *trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:2 repeats:NO];</span><br><span class="line">        </span><br><span class="line">        UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init];</span><br><span class="line">        content.title = @&quot;这是一条通知的标题&quot;;</span><br><span class="line">        content.body = @&quot;这是新的内容😀&quot;;</span><br><span class="line">        content.categoryIdentifier = @&quot;ceshi&quot;;</span><br><span class="line">        </span><br><span class="line">        // 创建一个通知请求</span><br><span class="line">        // 同一个标示的话就会覆盖之前的通知</span><br><span class="line">        UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:identifier content:content trigger:trigger];</span><br><span class="line">        </span><br><span class="line">        [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123;</span><br><span class="line">            if (!error) &#123;</span><br><span class="line">                NSLog(@&quot;新的通知添加成功&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>#通知处理</p>
<p>通知处理就是，处理用户直接和通知的交互。比如微信发过来一条消息，你可以直接在通知上进行回复，而不用打开微信app。</p>
<p><strong>应用内展示通知</strong></p>
<p>我们知道当APP在前台使用的过程中，在默认情况下，通知是没有任何提示的。但是要想有展示的效果，可以通过下面的代码设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// The method will be called on the delegate only if the application is in the foreground. If the method is not implemented or the handler is not called in a timely manner then the notification will not be presented. The application can choose to have the notification presented as a sound, badge, alert and/or in the notification list. This decision should be based on whether the information in the notification is otherwise visible to the user.</span><br><span class="line">- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    // 用户在前台使用APP的时候，收到通知，会调用此方法.</span><br><span class="line">    // 写这个回调代表，会在APP打开的情况下，弹出通知。</span><br><span class="line">    // 如果不复写次方法，或者`completionHandler();`，APP在前台收到通知将不会弹出提示。</span><br><span class="line">    completionHandler(UNNotificationPresentationOptionBadge | UNNotificationPresentationOptionSound | UNNotificationPresentationOptionAlert);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是通知中的代理方法，需要先设置代理、签协议。<code>&lt;UNUserNotificationCenterDelegate&gt;</code></p>
<blockquote>
<p>To guarantee that your app is able to respond to actionable notifications, you must set the value of this property before your app finishes launching. For example, this means assigning a delegate object to this property in an iOS app’s <code>application:willFinishLaunchingWithOptions:</code>or <code>application:didFinishLaunchingWithOptions:</code> method.</p>
</blockquote>
<p>需要注意的是，这个代理必须要在程序启动之前设置好。一般在 <code>application:didFinishLaunchingWithOptions:</code>这个方法设置就可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 设置代理</span><br><span class="line">[[UNUserNotificationCenter currentNotificationCenter] setDelegate:self];</span><br></pre></td></tr></table></figure>
<p><strong>处理用户和通知的交互</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     设置通知上面的交互按钮</span><br><span class="line">     UNNotificationActionOptionAuthenticationRequired //操作这个按钮会先检查iPhone是否解锁</span><br><span class="line">     UNNotificationActionOptionDestructive //按钮会被高亮标记（红色）</span><br><span class="line">     UNNotificationActionOptionForeground // 点击按钮会将APP唤起</span><br><span class="line">     */</span><br><span class="line">    UNNotificationAction *unlocking = [UNNotificationAction actionWithIdentifier:@&quot;unlocking&quot;</span><br><span class="line">                                                                           title:@&quot;unlocking&quot;</span><br><span class="line">                                                                         options:UNNotificationActionOptionAuthenticationRequired];</span><br><span class="line">    UNNotificationAction *destructive = [UNNotificationAction actionWithIdentifier:@&quot;destructive&quot;</span><br><span class="line">                                                                             title:@&quot;destructive&quot;</span><br><span class="line">                                                                           options:UNNotificationActionOptionDestructive];</span><br><span class="line">    UNNotificationAction *foreground = [UNNotificationAction actionWithIdentifier:@&quot;foreground&quot;</span><br><span class="line">                                                                            title:@&quot;foreground&quot;</span><br><span class="line">                                                                          options:UNNotificationActionOptionForeground];</span><br><span class="line">    UNTextInputNotificationAction *input = [UNTextInputNotificationAction actionWithIdentifier:@&quot;text&quot; title:@&quot;text&quot; options:UNNotificationActionOptionAuthenticationRequired textInputButtonTitle:@&quot;text_btn&quot; textInputPlaceholder:@&quot;placeholder&quot;];</span><br><span class="line">    // 注意：这里的category的标示如果和发送通知时，写的category标示不一样的时候，发过来的通知不会显示action！！！发送通知的时候可以不写标示。</span><br><span class="line">    // 我这里是，两边都写得 “ceshi”</span><br><span class="line">    UNNotificationCategory *category = [UNNotificationCategory categoryWithIdentifier:@&quot;ceshi&quot;</span><br><span class="line">                                                                              actions:@[unlocking, destructive, foreground, input] intentIdentifiers:@[@&quot;&quot;]</span><br><span class="line">                                                                              options:UNNotificationCategoryOptionNone];</span><br><span class="line">    </span><br><span class="line">    [[UNUserNotificationCenter currentNotificationCenter] setNotificationCategories:[NSSet setWithObject:category]];</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/852660-2fc26e066714dfc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UNNotification_text_01.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/852660-f511e53dc946f1e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UNNotification_text_02.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// The method will be called on the delegate when the user responded to the notification by opening the application, dismissing the notification or choosing a UNNotificationAction. The delegate must be set before the application returns from applicationDidFinishLaunching:.</span><br><span class="line">- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    //当用户是通过和通知的交互进入app的时候，拿到通知对象。</span><br><span class="line">    UNNotificationContent *content = response.notification.request.content;</span><br><span class="line">    </span><br><span class="line">    if ([content.categoryIdentifier isEqualToString:@&quot;ceshi&quot;]) &#123;</span><br><span class="line">        </span><br><span class="line">        if ([response.actionIdentifier isEqualToString:@&quot;text&quot;]) &#123;</span><br><span class="line">            UNTextInputNotificationResponse *textResp = (UNTextInputNotificationResponse *)response;</span><br><span class="line">            NSLog(@&quot;输入文字的内容是%@&quot;, textResp.userText);</span><br><span class="line">        &#125;</span><br><span class="line">        else if ([response.actionIdentifier isEqualToString:@&quot;unlocking&quot;]) &#123;</span><br><span class="line">            NSLog(@&quot;unlocking&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if ([response.actionIdentifier isEqualToString:@&quot;destructive&quot;]) &#123;</span><br><span class="line">            NSLog(@&quot;destructive&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if ([response.actionIdentifier isEqualToString:@&quot;foreground&quot;]) &#123;</span><br><span class="line">            NSLog(@&quot;foreground&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    completionHandler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>刚才我看评论，有一人问我是不是自己实践的😓,我都是自己尝试过，才发上去的，多谢大家支持。这里放上我的<a href="https://github.com/Hanwp/UNNotification.git" target="_blank" rel="external">Demo</a></p>
<p>关于通知发送富文本部分，正在整理，等整理好了，我会继续补充！</p>
</blockquote>
<p>2016-10-09补充：<br>多媒体通知已经更新：<a href="http://www.jianshu.com/p/d180211a3072" target="_blank" rel="external">iOS10新特性-UserNotifications(二)</a></p>
<blockquote>
<p>参考：<br><a href="https://onevcat.com/2016/08/notification/" target="_blank" rel="external">https://onevcat.com/2016/08/notification/</a></p>
</blockquote>
</div></article></div></section><footer><div class="paginator"><a href="/2016/10/09/iOS10新特性-UserNotifications（二）/" class="prev">PREV</a><a href="/2016/09/29/iOS10权限crash问题/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://hanwp.github.io">灭神</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>