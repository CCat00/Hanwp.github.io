<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>灭神的技术博客</title>
  <subtitle>记录成长的脚步。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hanwp.github.io/"/>
  <updated>2016-11-11T07:23:11.000Z</updated>
  <id>http://hanwp.github.io/</id>
  
  <author>
    <name>灭神</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>妙汇</title>
    <link href="http://hanwp.github.io/2016/11/10/%E5%A6%99%E6%B1%87/"/>
    <id>http://hanwp.github.io/2016/11/10/妙汇/</id>
    <published>2016-11-10T07:22:53.000Z</published>
    <updated>2016-11-11T07:23:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>前一段时间一直在零碎的学习swift的知识点，由于公司项目没有用swift开发，所以就想着找个项目模仿一下，练习一下swift。</p>
</blockquote>
<p>#效果图<br><img src="http://upload-images.jianshu.io/upload_images/852660-470944e57ae9631b.gif?imageMogr2/auto-orient/strip" alt="首页gif.gif"><br><img src="http://upload-images.jianshu.io/upload_images/852660-095a9a25c6da23b7.gif?imageMogr2/auto-orient/strip" alt="分类gif.gif"><br><img src="http://upload-images.jianshu.io/upload_images/852660-021879534e260af4.gif?imageMogr2/auto-orient/strip" alt="视野gif.gif"></p>
<p>#注意<br>这里我就不写怎么从零模仿APP了，抓包呀这些，网上好多。<br>我没有和官方的做的一模一样，只是大概实现了几个页面，能到到练手swift的目的就好😁。具体逻辑就看代码吧：<a href="https://github.com/Hanwp/miaohui--swift" target="_blank" rel="external">代码地址</a>。</p>
<blockquote>
<p>有什么问题欢迎给我留言~</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前一段时间一直在零碎的学习swift的知识点，由于公司项目没有用swift开发，所以就想着找个项目模仿一下，练习一下swift。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;#效果图&lt;br&gt;&lt;img src=&quot;http://upload-images
    
    </summary>
    
    
      <category term="iOS" scheme="http://hanwp.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS10新特性-UserNotifications（二）</title>
    <link href="http://hanwp.github.io/2016/10/09/iOS10%E6%96%B0%E7%89%B9%E6%80%A7-UserNotifications%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://hanwp.github.io/2016/10/09/iOS10新特性-UserNotifications（二）/</id>
    <published>2016-10-09T08:30:01.000Z</published>
    <updated>2016-11-11T07:22:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><a href="http://www.jianshu.com/p/6e7e269e6c62" target="_blank" rel="external">上篇文章</a>主要介绍了新的通知框架的基本使用，这篇文章主要说一下<strong>多媒体通知</strong>和<strong>扩展</strong>。</p>
</blockquote>
<p>#扩展（Notification Extension）</p>
<ul>
<li>Notification Service Extension<br>收到远程推送通知之后，我们可以利用<strong>Notification Service Extension</strong>这个扩展进行通知的修改。<br><img src="http://upload-images.jianshu.io/upload_images/852660-ae96bdc6dcdb4c09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="un_service_extension.png"></li>
</ul>
<p>建好target之后可以看到，系统就为我们实现了基本的方法。我这里在收到通知之后修改了<code>body</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import UserNotifications</span><br><span class="line"></span><br><span class="line">class NotificationService: UNNotificationServiceExtension &#123;</span><br><span class="line"></span><br><span class="line">    var contentHandler: ((UNNotificationContent) -&gt; Void)?</span><br><span class="line">    var bestAttemptContent: UNMutableNotificationContent?</span><br><span class="line"></span><br><span class="line">    override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -&gt; Void) &#123;</span><br><span class="line">        self.contentHandler = contentHandler</span><br><span class="line">        bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)</span><br><span class="line">        </span><br><span class="line">        if let bestAttemptContent = bestAttemptContent &#123;</span><br><span class="line">            // Modify the notification content here...</span><br><span class="line">            if bestAttemptContent.categoryIdentifier == &quot;ceshi&quot; &#123;</span><br><span class="line">                bestAttemptContent.body = &quot;\(bestAttemptContent.body) 加上修改内容了！&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            contentHandler(bestAttemptContent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func serviceExtensionTimeWillExpire() &#123;</span><br><span class="line">        // Called just before the extension will be terminated by the system.</span><br><span class="line">        // Use this as an opportunity to deliver your &quot;best attempt&quot; at modified content, otherwise the original push payload will be used.</span><br><span class="line">        if let contentHandler = contentHandler, let bestAttemptContent =  bestAttemptContent &#123;</span><br><span class="line">            contentHandler(bestAttemptContent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到结果：<br><img src="http://upload-images.jianshu.io/upload_images/852660-780cad11c6f89ba2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="un.extension.modify.png"></p>
<blockquote>
<p>注：<strong>Notification Service Extension</strong> 现在只对远程推送的通知有效。因此<a href="https://github.com/Hanwp/UNNotification.git" target="_blank" rel="external">Demo</a>中我集成了<a href="https://www.jiguang.cn" target="_blank" rel="external">极光推送</a>，为了方便测试使用。</p>
</blockquote>
<p><a href="https://onevcat.com/2016/08/notification/" target="_blank" rel="external">喵神</a>认为这个特性可以方便传输安全性的信息。下面是他的blog原话：</p>
<blockquote>
<p>使用在本机截取推送并替换内容的方式，可以完成端到端 (end-to-end) 的推送加密。你在服务器推送 payload 中加入加密过的文本，在客户端接到通知后使用预先定义或者获取过的密钥进行解密，然后立即显示。这样一来，即使推送信道被第三方截取，其中所传递的内容也还是安全的。使用这种方式来发送密码或者敏感信息，对于一些金融业务应用和聊天应用来说，应该是必备的特性。</p>
</blockquote>
<ul>
<li>Notification Content Extension<br>我们可以利用<strong>Notification Content Extension</strong>这个扩展进行通知视图的自定义。<br><img src="http://upload-images.jianshu.io/upload_images/852660-26dbdf451b043254.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="un.content.create.png"></li>
</ul>
<p><code>NotificationViewController</code>继承于普通的<code>UIViewController</code>，我们可以自己定义各种UI。这里就是创建好之后，默认自带的一个label。</p>
<blockquote>
<p>注意：需要在info.plist文件里设置对应的<code>UNNotificationExtensionCategory</code>要不然，这个自定义的UI是不起作用的。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/852660-1252f5fb605bd243.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="un.content.info.plist.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/852660-714c30c8b0dc647c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="un.content.plist.categoryIden.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NotificationViewController.h&quot;</span><br><span class="line">#import &lt;UserNotifications/UserNotifications.h&gt;</span><br><span class="line">#import &lt;UserNotificationsUI/UserNotificationsUI.h&gt;</span><br><span class="line"></span><br><span class="line">@interface NotificationViewController () &lt;UNNotificationContentExtension&gt;</span><br><span class="line"></span><br><span class="line">@property IBOutlet UILabel *label;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NotificationViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any required interface initialization here.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveNotification:(UNNotification *)notification &#123;</span><br><span class="line">    self.label.text = @&quot;这是自定义的label&quot;;//notification.request.content.body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="http://upload-images.jianshu.io/upload_images/852660-a5081d84154a7819.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="un.content.customUI.png"></p>
<p>#多媒体通知(通知中携带图片、音频、视频)<br>具体文件类型和大小限制如下：<br><img src="http://upload-images.jianshu.io/upload_images/852660-46302cb765262cc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="un.attachment.supportFileType.png"></p>
<ul>
<li>为本地通知增加多媒体内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//多媒体通知(发送一个图片)</span><br><span class="line">NSString *imagePath = [[NSBundle mainBundle] pathForResource:@&quot;attachment_pic&quot; ofType:@&quot;jpg&quot;];</span><br><span class="line">NSURL *imageURL = [NSURL fileURLWithPath:imagePath];</span><br><span class="line">UNNotificationAttachment *attachment = [UNNotificationAttachment attachmentWithIdentifier:@&quot;attachment.identifier&quot; URL:imageURL options:nil error:nil];</span><br><span class="line">content.attachments = @[attachment,attachment];</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="http://upload-images.jianshu.io/upload_images/852660-cfbe640c1f767f98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="attachment_pic.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/852660-ed221866e7dbe42c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="attachment_pic_big.png"></p>
<p>可以添加音频：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//多媒体通知(发送一个mp3)</span><br><span class="line">    NSString *mp3Path = [[NSBundle mainBundle] pathForResource:@&quot;Fly&quot; ofType:@&quot;mp3&quot;];</span><br><span class="line">    NSURL *mp3URL = [NSURL fileURLWithPath:mp3Path];</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    UNNotificationAttachment *mp3Attachment = [UNNotificationAttachment attachmentWithIdentifier:@&quot;mp3.attachment.identifier&quot; URL:mp3URL options:nil error:&amp;error];</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;error = %@&quot;, error);</span><br><span class="line">    &#125;</span><br><span class="line">    content.attachments = @[mp3Attachment];</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><img src="http://upload-images.jianshu.io/upload_images/852660-413b9cefc3c64ccc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="un.test.mp3.png"></p>
<blockquote>
<p>如果同时添加了图片和mp3也就是添加多个附件的时候，只会展示第一个。</p>
</blockquote>
<p>因为没有合适的视频，视频我估计也就差不多，我这边就不测试了。</p>
<ul>
<li>为远程通知增加多媒体内容<br>远程通知携带多媒体内容需要借助上面提到的<strong>Notification Service Extension</strong>，在拦截到通知的时候，可以是一个远程的url，也可以是bundle中的一个url，在处理完之后，更改通知的<code>attachment</code>就可以了。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/6e7e269e6c62&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上篇文章&lt;/a&gt;主要介绍了新的通知框架的基本使用，这篇文章主要说一下&lt;strong&gt;多媒体
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS10新特性-UserNotifications</title>
    <link href="http://hanwp.github.io/2016/10/08/iOS10%E6%96%B0%E7%89%B9%E6%80%A7-UserNotifications/"/>
    <id>http://hanwp.github.io/2016/10/08/iOS10新特性-UserNotifications/</id>
    <published>2016-10-08T03:30:12.000Z</published>
    <updated>2016-11-11T07:20:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>iOS10增加了新的通知框架<code>UserNotifications</code>，整合了本地通知和APNS，新的API使用起来特别舒服。这篇文章就大概介绍一下新的框架。</p>
</blockquote>
<p>###新的特性：</p>
<ul>
<li>通知可以附加图片、音频、视频</li>
<li>可以对通知更新、删除</li>
<li>统一本地通知和APNS</li>
</ul>
<p>#权限申请<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@import UserNotifications;</span><br><span class="line">// 请求使用通知</span><br><span class="line">[[UNUserNotificationCenter currentNotificationCenter] requestAuthorizationWithOptions:UNAuthorizationOptionBadge | UNAuthorizationOptionSound | UNAuthorizationOptionAlert completionHandler:^(BOOL granted, NSError * _Nullable error) &#123;</span><br><span class="line">       if (granted) &#123;</span><br><span class="line">           //用户同意使用通知</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure></p>
<p>第一次调用这个方法时，会弹出一个系统弹窗。<br><img src="http://upload-images.jianshu.io/upload_images/852660-bf32a6da0243c4c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UNNotification_author.png"><br>要注意的是，一旦用户拒绝了这个请求，再次调用该方法也不会再进行弹窗，想要应用有机会接收到通知的话，用户必须自行前往系统的设置中为你的应用打开通知。</p>
<p><em>远程推送</em></p>
<p>用户同意了通知申请之后，就可以进行本地通知了。如果要进行远程推送，还需要获取token。然后服务器根据这个token，向<code>Apple Push Notification Service</code>服务器提交请求，然后<code>APNS</code>通过token识别用户，推送给用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//向APNS请求token</span><br><span class="line">    [[UIApplication sharedApplication] registerForRemoteNotifications];</span><br><span class="line">//请求token成功</span><br><span class="line">- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通知权限</strong><br>可以通知下面的这个方法，检查当前APP的通知权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[UNUserNotificationCenter currentNotificationCenter] getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) &#123;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p>
<p>#发送通知<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 创建通知</span><br><span class="line">    UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init];</span><br><span class="line">    content.title = @&quot;这是一条通知的标题&quot;;</span><br><span class="line">    content.body = @&quot;这是一条通知的内容&quot;;</span><br><span class="line">    content.categoryIdentifier = @&quot;ceshi&quot;;</span><br><span class="line">    </span><br><span class="line">    // 创建发送触发</span><br><span class="line">    UNTimeIntervalNotificationTrigger *trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:5 repeats:NO];</span><br><span class="line">    </span><br><span class="line">    // 发送请求标识符</span><br><span class="line">    NSString *identifier = @&quot;com.hanwei.firstNotificationIndentifier&quot;;</span><br><span class="line">    </span><br><span class="line">    // 创建一个通知请求</span><br><span class="line">    UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:identifier content:content trigger:trigger];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 将请求添加到通知中心</span><br><span class="line">    [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123;</span><br><span class="line">        if (!error) &#123;</span><br><span class="line">            NSLog(@&quot;通知添加成功&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p>
<p>发送通知成功之后，就可以回到首页，或者锁屏查看了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/852660-7380841edf400908.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UNNotification_home.png"></p>
<p>#取消和更新通知<br>远程推送只能更新，不能取消已经展示过的通知。<br><em>取消</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 移除展示过的通知</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(6 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [[UNUserNotificationCenter currentNotificationCenter] removeDeliveredNotificationsWithIdentifiers:@[identifier]];</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"> //移除还未展示的通知</span><br><span class="line">[[UNUserNotificationCenter currentNotificationCenter] removePendingNotificationRequestsWithIdentifiers:@[identifier]];</span><br></pre></td></tr></table></figure></p>
<p><strong>更新</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    // 不管通知是否已经展示过，都可以根据标示进行通知的更新</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(8 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">//        NSLog(@&quot;两秒钟后更新通知内容&quot;);</span><br><span class="line">        </span><br><span class="line">        // 创建发送触发</span><br><span class="line">        UNTimeIntervalNotificationTrigger *trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:2 repeats:NO];</span><br><span class="line">        </span><br><span class="line">        UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init];</span><br><span class="line">        content.title = @&quot;这是一条通知的标题&quot;;</span><br><span class="line">        content.body = @&quot;这是新的内容😀&quot;;</span><br><span class="line">        content.categoryIdentifier = @&quot;ceshi&quot;;</span><br><span class="line">        </span><br><span class="line">        // 创建一个通知请求</span><br><span class="line">        // 同一个标示的话就会覆盖之前的通知</span><br><span class="line">        UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:identifier content:content trigger:trigger];</span><br><span class="line">        </span><br><span class="line">        [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123;</span><br><span class="line">            if (!error) &#123;</span><br><span class="line">                NSLog(@&quot;新的通知添加成功&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>#通知处理</p>
<p>通知处理就是，处理用户直接和通知的交互。比如微信发过来一条消息，你可以直接在通知上进行回复，而不用打开微信app。</p>
<p><strong>应用内展示通知</strong></p>
<p>我们知道当APP在前台使用的过程中，在默认情况下，通知是没有任何提示的。但是要想有展示的效果，可以通过下面的代码设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// The method will be called on the delegate only if the application is in the foreground. If the method is not implemented or the handler is not called in a timely manner then the notification will not be presented. The application can choose to have the notification presented as a sound, badge, alert and/or in the notification list. This decision should be based on whether the information in the notification is otherwise visible to the user.</span><br><span class="line">- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    // 用户在前台使用APP的时候，收到通知，会调用此方法.</span><br><span class="line">    // 写这个回调代表，会在APP打开的情况下，弹出通知。</span><br><span class="line">    // 如果不复写次方法，或者`completionHandler();`，APP在前台收到通知将不会弹出提示。</span><br><span class="line">    completionHandler(UNNotificationPresentationOptionBadge | UNNotificationPresentationOptionSound | UNNotificationPresentationOptionAlert);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是通知中的代理方法，需要先设置代理、签协议。<code>&lt;UNUserNotificationCenterDelegate&gt;</code></p>
<blockquote>
<p>To guarantee that your app is able to respond to actionable notifications, you must set the value of this property before your app finishes launching. For example, this means assigning a delegate object to this property in an iOS app’s <code>application:willFinishLaunchingWithOptions:</code>or <code>application:didFinishLaunchingWithOptions:</code> method.</p>
</blockquote>
<p>需要注意的是，这个代理必须要在程序启动之前设置好。一般在 <code>application:didFinishLaunchingWithOptions:</code>这个方法设置就可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 设置代理</span><br><span class="line">[[UNUserNotificationCenter currentNotificationCenter] setDelegate:self];</span><br></pre></td></tr></table></figure>
<p><strong>处理用户和通知的交互</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     设置通知上面的交互按钮</span><br><span class="line">     UNNotificationActionOptionAuthenticationRequired //操作这个按钮会先检查iPhone是否解锁</span><br><span class="line">     UNNotificationActionOptionDestructive //按钮会被高亮标记（红色）</span><br><span class="line">     UNNotificationActionOptionForeground // 点击按钮会将APP唤起</span><br><span class="line">     */</span><br><span class="line">    UNNotificationAction *unlocking = [UNNotificationAction actionWithIdentifier:@&quot;unlocking&quot;</span><br><span class="line">                                                                           title:@&quot;unlocking&quot;</span><br><span class="line">                                                                         options:UNNotificationActionOptionAuthenticationRequired];</span><br><span class="line">    UNNotificationAction *destructive = [UNNotificationAction actionWithIdentifier:@&quot;destructive&quot;</span><br><span class="line">                                                                             title:@&quot;destructive&quot;</span><br><span class="line">                                                                           options:UNNotificationActionOptionDestructive];</span><br><span class="line">    UNNotificationAction *foreground = [UNNotificationAction actionWithIdentifier:@&quot;foreground&quot;</span><br><span class="line">                                                                            title:@&quot;foreground&quot;</span><br><span class="line">                                                                          options:UNNotificationActionOptionForeground];</span><br><span class="line">    UNTextInputNotificationAction *input = [UNTextInputNotificationAction actionWithIdentifier:@&quot;text&quot; title:@&quot;text&quot; options:UNNotificationActionOptionAuthenticationRequired textInputButtonTitle:@&quot;text_btn&quot; textInputPlaceholder:@&quot;placeholder&quot;];</span><br><span class="line">    // 注意：这里的category的标示如果和发送通知时，写的category标示不一样的时候，发过来的通知不会显示action！！！发送通知的时候可以不写标示。</span><br><span class="line">    // 我这里是，两边都写得 “ceshi”</span><br><span class="line">    UNNotificationCategory *category = [UNNotificationCategory categoryWithIdentifier:@&quot;ceshi&quot;</span><br><span class="line">                                                                              actions:@[unlocking, destructive, foreground, input] intentIdentifiers:@[@&quot;&quot;]</span><br><span class="line">                                                                              options:UNNotificationCategoryOptionNone];</span><br><span class="line">    </span><br><span class="line">    [[UNUserNotificationCenter currentNotificationCenter] setNotificationCategories:[NSSet setWithObject:category]];</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/852660-2fc26e066714dfc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UNNotification_text_01.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/852660-f511e53dc946f1e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UNNotification_text_02.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// The method will be called on the delegate when the user responded to the notification by opening the application, dismissing the notification or choosing a UNNotificationAction. The delegate must be set before the application returns from applicationDidFinishLaunching:.</span><br><span class="line">- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    //当用户是通过和通知的交互进入app的时候，拿到通知对象。</span><br><span class="line">    UNNotificationContent *content = response.notification.request.content;</span><br><span class="line">    </span><br><span class="line">    if ([content.categoryIdentifier isEqualToString:@&quot;ceshi&quot;]) &#123;</span><br><span class="line">        </span><br><span class="line">        if ([response.actionIdentifier isEqualToString:@&quot;text&quot;]) &#123;</span><br><span class="line">            UNTextInputNotificationResponse *textResp = (UNTextInputNotificationResponse *)response;</span><br><span class="line">            NSLog(@&quot;输入文字的内容是%@&quot;, textResp.userText);</span><br><span class="line">        &#125;</span><br><span class="line">        else if ([response.actionIdentifier isEqualToString:@&quot;unlocking&quot;]) &#123;</span><br><span class="line">            NSLog(@&quot;unlocking&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if ([response.actionIdentifier isEqualToString:@&quot;destructive&quot;]) &#123;</span><br><span class="line">            NSLog(@&quot;destructive&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if ([response.actionIdentifier isEqualToString:@&quot;foreground&quot;]) &#123;</span><br><span class="line">            NSLog(@&quot;foreground&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    completionHandler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>刚才我看评论，有一人问我是不是自己实践的😓,我都是自己尝试过，才发上去的，多谢大家支持。这里放上我的<a href="https://github.com/Hanwp/UNNotification.git" target="_blank" rel="external">Demo</a></p>
<p>关于通知发送富文本部分，正在整理，等整理好了，我会继续补充！</p>
</blockquote>
<p>2016-10-09补充：<br>多媒体通知已经更新：<a href="http://www.jianshu.com/p/d180211a3072" target="_blank" rel="external">iOS10新特性-UserNotifications(二)</a></p>
<blockquote>
<p>参考：<br><a href="https://onevcat.com/2016/08/notification/" target="_blank" rel="external">https://onevcat.com/2016/08/notification/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;iOS10增加了新的通知框架&lt;code&gt;UserNotifications&lt;/code&gt;，整合了本地通知和APNS，新的API使用起来特别舒服。这篇文章就大概介绍一下新的框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###新的特性：&lt;/p&gt;
&lt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://hanwp.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS10权限crash问题</title>
    <link href="http://hanwp.github.io/2016/09/29/iOS10%E6%9D%83%E9%99%90crash%E9%97%AE%E9%A2%98/"/>
    <id>http://hanwp.github.io/2016/09/29/iOS10权限crash问题/</id>
    <published>2016-09-29T03:10:16.000Z</published>
    <updated>2016-11-11T07:18:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来苹果都特别注重用户的隐私问题，比如访问联系人和打开相册都会弹出一个提示，来征求用户的意见，iOS10更加完善了这方面的权限。</p>
<blockquote>
<p><strong>A significant change in iOS 10 is that you must declare ahead of time any access to private data or your App will crash.</strong> </p>
</blockquote>
<p>在访问下列信息的时候，需要在<code>info.plist</code>文件里，加上访问说明。</p>
<blockquote>
<p>Contacts, Calendar, Reminders, Photos, Bluetooth Sharing, Microphone, Camera, Location, Health, HomeKit, Media Library, Motion, CallKit, Speech Recognition, SiriKit, TV Provider.</p>
</blockquote>
<p>否则就会造成崩溃，这是我没有加说明的情况下，试图访问图库的一个崩溃</p>
<blockquote>
<p>This app has crashed because it attempted to access privacy-sensitive data without a usage description.  The app’s Info.plist must contain an NSPhotoLibraryUsageDescription key with a string value explaining to the user how the app uses this data.</p>
</blockquote>
<p>可以直接在<code>info.plist</code>里添加键值对，输入<code>Privacy</code>就会有提示了。<br><img src="http://upload-images.jianshu.io/upload_images/852660-3b093db8667a7f85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Privacy_info.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/852660-3235757766d715b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Privacy_alert.png"></p>
<p>也可以以<code>Source Code</code>的方式打开<code>info.plist</code>，然后粘贴下面的字段。<br>下面列出所有的字段，方便以后粘贴使用。<br><img src="http://upload-images.jianshu.io/upload_images/852660-dd3b8a7e20435d7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="info_source_code.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;NSVideoSubscriberAccountUsageDescription&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;视频认证&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;NSSpeechRecognitionUsageDescription&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;语音识别&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;NSSiriUsageDescription&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;Siri使用&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;NSRemindersUsageDescription&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;访问提醒事项&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;kTCCServiceMediaLibrary&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;TV控制&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;NSMotionUsageDescription&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;运动权限&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;麦克风权限&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;NSAppleMusicUsageDescription&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;苹果音乐&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;NSLocationUsageDescription&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;位置权限&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;NSHomeKitUsageDescription&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;HomeKit权限&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;NSHealthUpdateUsageDescription&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;健康应用&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;NSHealthShareUsageDescription&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;健康应用&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;NSContactsUsageDescription&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;通讯录&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;NSCalendarsUsageDescription&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;日历&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;蓝牙&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;相册&lt;/string&gt;</span><br><span class="line">	&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;</span><br><span class="line">	&lt;string&gt;相机&lt;/string&gt;</span><br><span class="line">    &lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;永久使用定位&lt;/string&gt;</span><br><span class="line">    &lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;应用使用的时候使用定位&lt;/string&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>参考：<br><a href="http://useyourloaf.com/blog/privacy-settings-in-ios-10/" target="_blank" rel="external">http://useyourloaf.com/blog/privacy-settings-in-ios-10/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来苹果都特别注重用户的隐私问题，比如访问联系人和打开相册都会弹出一个提示，来征求用户的意见，iOS10更加完善了这方面的权限。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;A significant change in iOS 10 is that you
    
    </summary>
    
    
      <category term="iOS" scheme="http://hanwp.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods报错问题</title>
    <link href="http://hanwp.github.io/2016/04/12/CocoaPods%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
    <id>http://hanwp.github.io/2016/04/12/CocoaPods报错问题/</id>
    <published>2016-04-12T02:14:39.000Z</published>
    <updated>2016-11-11T07:17:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>使用CocoaPods管理第三方框架非常方便，但是有时候也会出现一些问题。</p>
</blockquote>
<h1 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h1><p>今天下载了<a href="https://github.com/Coding/Coding-iOS.git" target="_blank" rel="external">Coding</a>源码，打算研究一下。按照提示执行了脚本之后发现，还是会报这么一个错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">diff: /../Podfile.lock: No such file or directory</span><br><span class="line">diff: /Manifest.lock: No such file or directory</span><br><span class="line">error: The sandbox is not in sync with the Podfile.lock. Run &apos;pod install&apos; or update your CocoaPods installation.</span><br></pre></td></tr></table></figure></p>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>于是我就重新<code>pod install</code>发现还是不行，接着就是各种<code>Google</code>，然后找到了<a href="http://stackoverflow.com/questions/17072396/cocoapods-errors-on-project-build" target="_blank" rel="external">这种方法</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//先把项目的Myproject.workspeace删除</span><br><span class="line">rm -rf MyProject.xcworkspace</span><br><span class="line">//再重新pod </span><br><span class="line">pod install</span><br></pre></td></tr></table></figure></p>
<p>按照步骤执行了之后，发现还是不行。（但是好像是有的人这么解决就可以。）</p>
<p>然后我发现在<code>pod install</code>的时候，终端会有这么两个提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[!] CocoaPods did not set the base configuration of your project because your project already has a custom config set. In order for CocoaPods integration to work at all, please either set the base configurations of the target `Coding_iOS` to `Pods/Target Support Files/Pods-Coding_iOS/Pods-Coding_iOS.debug.xcconfig` or include the `Pods/Target Support Files/Pods-Coding_iOS/Pods-Coding_iOS.debug.xcconfig` in your build configuration.</span><br><span class="line"></span><br><span class="line">[!] CocoaPods did not set the base configuration of your project because your project already has a custom config set. In order for CocoaPods integration to work at all, please either set the base configurations of the target `Coding_iOS` to `Pods/Target Support Files/Pods-Coding_iOS/Pods-Coding_iOS.release.xcconfig` or include the `Pods/Target Support Files/Pods-Coding_iOS/Pods-Coding_iOS.release.xcconfig` in your build configuration.</span><br></pre></td></tr></table></figure></p>
<p>然后抓住这个线索我又找到了<a href="http://stackoverflow.com/questions/26287103/cocoapods-warning-cocoapods-did-not-set-the-base-configuration-of-your-project" target="_blank" rel="external">最终解决办法</a>：</p>
<p>先在项目里把下面的<code>Configuration</code>都改为<code>None</code>,然后在<code>pod install</code>。这样就解决了。<br><img src="http://upload-images.jianshu.io/upload_images/852660-077dd1adbadf3b16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pic1"></p>
<p><strong>2016-6-14补充</strong><br>在我新项目里，我设置了多个target，用cocoaPods又出现了下面的错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[!] The `PuHuaHospital [Release]` target overrides the `GCC_PREPROCESSOR_DEFINITIONS` build setting defined in `Pods/Target Support Files/Pods-PuHuaHospital/Pods-PuHuaHospital.release.xcconfig&apos;. This can lead to problems with the CocoaPods installation</span><br><span class="line">    - Use the `$(inherited)` flag, or</span><br><span class="line">    - Remove the build settings from the target.</span><br><span class="line"></span><br><span class="line">[!] The `PuHuaHospitalDoctor [Release]` target overrides the `GCC_PREPROCESSOR_DEFINITIONS` build setting defined in `Pods/Target Support Files/Pods-PuHuaHospitalDoctor/Pods-PuHuaHospitalDoctor.release.xcconfig&apos;. This can lead to problems with the CocoaPods installation</span><br><span class="line">    - Use the `$(inherited)` flag, or</span><br><span class="line">    - Remove the build settings from the target.</span><br></pre></td></tr></table></figure>
<p><a href="http://stackoverflow.com/questions/18376416/the-target-overrides-the-other-ldflags-build-setting-defined-in-pods-pods" target="_blank" rel="external">解决办法</a>：<br>在<code>Build Settings</code><br>Header Search Paths<br>Other Linker Flags<br>Preprocessor Macros<br>在这三个地方都加上<code>$(inherited)</code>，然后重新<code>pod install</code>就可以了。</p>
<blockquote>
<p>如果有不明白的，请给我留言，谢谢。多谢支持~</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;使用CocoaPods管理第三方框架非常方便，但是有时候也会出现一些问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;问题来源&quot;&gt;&lt;a href=&quot;#问题来源&quot; class=&quot;headerlink&quot; title=&quot;问题来源&quot;&gt;&lt;/a&gt;问题
    
    </summary>
    
    
      <category term="iOS" scheme="http://hanwp.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>instancetype</title>
    <link href="http://hanwp.github.io/2016/04/09/instancetype/"/>
    <id>http://hanwp.github.io/2016/04/09/instancetype/</id>
    <published>2016-04-09T09:12:47.000Z</published>
    <updated>2016-11-11T07:13:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文章翻译自官方文档</p>
</blockquote>
<p>使用<code>instancetype</code>关键字作为方法的返回值，能够返回一个类的实例。比如<code>alloc</code>,<code>init</code>等方法。<br>在一个合适的地方使用<code>instancetype</code>取代<code>id</code>将使你的代码更加安全。看下下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface MyObject : NSObject</span><br><span class="line">+ (instancetype)factoryMethodA;</span><br><span class="line">+ (id)factoryMethodB;</span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line">@implementation MyObject</span><br><span class="line">+ (instancetype)factoryMethodA &#123; return [[[self class] alloc] init]; &#125;</span><br><span class="line">+ (id)factoryMethodB &#123; return [[[self class] alloc] init]; &#125;</span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line">void doSomething() &#123;</span><br><span class="line">    NSUInteger x, y;</span><br><span class="line"> </span><br><span class="line">    x = [[MyObject factoryMethodA] count]; // Return type of +factoryMethodA is taken to be &quot;MyObject *&quot;</span><br><span class="line">    y = [[MyObject factoryMethodB] count]; // Return type of +factoryMethodB is &quot;id&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法<code>+factoryMethodA</code>的返回值是<code>instancetype</code>类型，即<code>MyObject *</code>类型。由于<code>MyObject</code>这个类没有<code>-count</code>这个方法，所以编译器会在<code>x</code>行给出这么一个警告：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.m: ’MyObject’ may not respond to ‘count’</span><br></pre></td></tr></table></figure></p>
<p>然而，由于方法<code>+factoryMethodB</code>的返回值是<code>id</code>类型，所以编译器在<code>y</code>行没有任何警告。</p>
<p>还有下面这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface MyObjectSubclass : MyObject</span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line">void doSomethingElse() &#123;</span><br><span class="line">        NSString *aString = [MyObjectSubclass factoryMethodA];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译器会报如下警告：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.m: Incompatible pointer types initializing ’NSString *’ with an expression of type ’MyObjectSubclass *’</span><br></pre></td></tr></table></figure></p>
<p>这两个例子就能大致说明<code>instancetype</code>和<code>id</code>的区别了。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>翻译本文的目的，最主要的目的是让我自己慢慢适应看官方文档，因为咱们学习iOS的所有权威的资料都来自apple开发者网站，所以看文档也是最直接和最有效的方式。</p>
<blockquote>
<p>最后，内容有翻译错误和不准确的地方请大家帮我指正，谢谢。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文章翻译自官方文档&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用&lt;code&gt;instancetype&lt;/code&gt;关键字作为方法的返回值，能够返回一个类的实例。比如&lt;code&gt;alloc&lt;/code&gt;,&lt;code&gt;init&lt;/code&gt;等方法。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>扇形图</title>
    <link href="http://hanwp.github.io/2016/04/01/%E6%89%87%E5%BD%A2%E5%9B%BE/"/>
    <id>http://hanwp.github.io/2016/04/01/扇形图/</id>
    <published>2016-04-01T03:07:15.000Z</published>
    <updated>2016-11-11T07:08:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>项目中一个界面包含了扇形图，是下面这个样子。于是这里先写了一个简单的实现（是固定死的比例，以后再加比例就OK了）。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/852660-f5277c97c9b7a993.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>利用<code>CAShapeLayer</code>和<code>UIBezierPath</code>绘制。</p>
<h1 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CAShapeLayer *circle = [CAShapeLayer layer];</span><br><span class="line">    circle.lineWidth = lineWidth1;</span><br><span class="line">    circle.path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(kScreenWidth/2, kScreenHeight/2) radius:raidus1 startAngle:0 endAngle:-2*M_PI clockwise:NO].CGPath;</span><br><span class="line">    circle.strokeColor = [UIColor whiteColor].CGColor;</span><br><span class="line">    circle.fillColor = [UIColor lightGrayColor].CGColor;</span><br><span class="line">    [self.view.layer addSublayer:circle];</span><br></pre></td></tr></table></figure>
<p>有一点需要注意的是<code>lineWidth</code>这个属性设置了之后会有一半覆盖掉半径，也就是说半径是100的话，设置<code>lineWidth</code>为50的话，看到的效果是里面的半径是100-50/2=75.（我当时找了好久的原因才发现这个问题）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/852660-50421d8b23f53e37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>到这里就结束了，其实发现这个还是很简单的。这里有我完整的代码：<a href="https://github.com/Hanwp/CAShapeLayer.git" target="_blank" rel="external">点我查看</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目中一个界面包含了扇形图，是下面这个样子。于是这里先写了一个简单的实现（是固定死的比例，以后再加比例就OK了）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upl
    
    </summary>
    
    
      <category term="iOS" scheme="http://hanwp.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式之单利（Singleton）</title>
    <link href="http://hanwp.github.io/2016/03/30/%E5%8D%95%E5%88%A9/"/>
    <id>http://hanwp.github.io/2016/03/30/单利/</id>
    <published>2016-03-30T07:02:14.000Z</published>
    <updated>2016-11-11T07:05:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>单利是一种设计模式，就是在应用程序生命周期中，只会创建一个对象实例。在保存用户的信息、数据管理者等需要使用到单利。系统也有一些单利的例子：<code>UIApplication</code>和<code>NSUserDefaults</code>等。</p>
<h1 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h1><ul>
<li>利用<code>GCD</code>创建</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static Signleton *signleton = nil;</span><br><span class="line"></span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">signleton = [super allocWithZone:zone];</span><br><span class="line">&#125;);</span><br><span class="line">return signleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (Signleton *)shareSignleton</span><br><span class="line">&#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">signleton = [[self alloc] init];</span><br><span class="line">&#125;);</span><br><span class="line">return signleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (id)copyWithZone:(struct _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">return signleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (id)mutableCopyWithZone:(struct _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">return signleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>还有就是普通的创建</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">static Signleton *signleton = nil;</span><br><span class="line"></span><br><span class="line">+ (Signleton *)shareSignleton</span><br><span class="line">&#123;</span><br><span class="line">//这里加锁是因为防止多线程同时调用</span><br><span class="line">@synchronized(self) &#123;</span><br><span class="line">if (!signleton) &#123;</span><br><span class="line">signleton = [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">return signleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">@synchronized(self) &#123;</span><br><span class="line">if (!signleton) &#123;</span><br><span class="line">//调用父类分配内存空间</span><br><span class="line">signleton = [super allocWithZone:zone];</span><br><span class="line">&#125;</span><br><span class="line">return signleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (id)copyWithZone:(struct _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">return signleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (id)mutableCopyWithZone:(struct _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">return signleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// MRC情况下，需要额外写以下方法</span><br><span class="line">- (oneway void)release</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSUInteger)retainCount</span><br><span class="line">&#123;</span><br><span class="line">return INT32_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)autorelease</span><br><span class="line">&#123;</span><br><span class="line">return signleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)retain</span><br><span class="line">&#123;</span><br><span class="line">return signleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;单利是一种设计模式，就是在应用程序生命周期中，只会创建一个对象实例。在保存用户的信息、数据管理者等需要使用到单利。系统也有一些单利的例子：&lt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://hanwp.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
